---
layout: post
title: "双蛋寻找最低临界楼层问题"
date:  2021-03-15
tags: [interview]
comments: true
toc: true
author: OJumpyo

---  

## 两个鸡蛋，最少的次数寻找蛋不碎的临界楼层 
本题来源：[力扣第887题，鸡蛋掉落。谷歌的经典面试题。谷歌，yyds](https://leetcode-cn.com/problems/super-egg-drop/)
### 问题描述：  
~~~
我有k个鸡蛋，去测试一个n层楼的建筑。
我的鸡蛋有些特殊，低于某一层楼的时候，怎么扔都不会碎。
现在我想要知道，我最少需要扔几次确定这个楼层是第几层。并且一定能确认  
~~~
**现在以特例开始考虑，假设是k=2，n=100.**  

### 思路：  
- 假如只有1个鸡蛋，那必然是从底层往上测试，最坏情况是O(n).  
- 加入有无限多个鸡蛋，那必然是二分法，直接二分确定区间。这种情况最坏情况是O(logn).   
- 现在来看，鸡蛋只有两个的情况。

**等间隔扔**  
每隔10层开始扔第一个，10，20，30，... ，100. 剩下的就只要在1-9，11-19，... ，91-99扔。最少扔10次，最多扔19次。  
这里间隔取的是sqrt(n)。  

**优选法，刚开始间隔大，越后面间隔越小。**  
- 以此处k=2,n=100举例。  
- 如果我每次使间隔缩小1，那么使用的就是(1+2+3+...+k)>100.  
- 得`k² + k > 100 * 2`.解得：`k > 13.65`，取 k = 14.  
- 第一次扔： 14 27  39  50  60  69  77  84  90  95  99  100
- 第二次扔： 1-13   14-26   28-38   ...  
此时最差扔： 1+13=14次，最好扔：11次，即99层不碎

## 引出得推广问题：k个鸡蛋，n层楼，k小于n得情况如何扔？  
这里来看边界问题：  
| 楼层数目\鸡蛋个数 | 1 | 2 | 3 | 4 | ... | k |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 2 |   |   |   |   |   |
| 3 | 3 |   |   |   |   |   |
| ... | ... |   |   |   |   |   |
| n | n |   |   |   |   |   |   |

可以看出，鸡蛋数只有一个得时候，随楼层数目增加，而增加需要检验得次数。此处不考虑边界问题，即扔了n-1次以后，不用再扔一次确定n层楼是否碎掉得情况  
而当楼层只有1层得时候，不管有多少个鸡蛋，都需要扔1次。这两个就是边界情况。  

现在考虑，**递归解法**。  
假设状态表示为(k,n),其中k为鸡蛋数目，n为楼层数目。当我们从第x层楼扔鸡蛋得时候：  
    - 如果鸡蛋不碎，那么状态变成 (k, n-x)，即我们鸡蛋的数目不变，但答案只可能在上方的 n-x 层楼了。也就是说，我们把原问题缩小成了一个规模为 (k, n-x) 的子问题；
    - 如果鸡蛋碎了，那么状态变成 (k-1, x-1)，即我们少了一个鸡蛋，但我们知道答案只可能在第 x 楼下方的 x-1 层楼中了。也就是说，我们把原问题缩小成了一个规模为 (k-1, x-1) 的子问题。
这样一来，我们定义 dp(k,n) 为在状态 (k, n) 下最少需要的步数。根据以上分析我们可以列出状态转移方程：
~~~
    dp(n,k) = 1 + min(1 ≤ x ≤ n){max [dp(k-1, x-1), dp(k, n-x)] }
~~~
解释：  
max [dp(k-1, x-1), dp(k, n-x)] ：这里是找到，x层碎和不碎两种情况下，最坏还需要找多少次。因此二者当中取最大值。
min(1 ≤ x ≤ n){} ： 这里是找到，我如果第一次选取得楼层x是哪一层得情况下，使得后续我扔鸡蛋次数最少得情况。所以遍历1-n，选取其中得最小值。  
记住：由于已经扔了一次鸡蛋，所以要+1  

如果我们直接暴力转移求解每个状态的 dp 值，时间复杂度是为 O(kn^2)  
即一共有 O(kn) 个状态，对于每个状态枚举扔鸡蛋的楼层 x，需要 O(n) 的时间。这无疑在题目指定数据范围下是会超出时间限制的，因此我们需要想办法优化枚举的时间复杂度。

我们观察到 dp(k,n) 是一个关于 n 的单调递增函数，也就是说在鸡蛋数 k 固定的情况下，楼层数 n 越多，需要的步数一定不会变少。在上述的状态转移方程中，  
第一项 `T1(x) = dp(k-1, x-1)`  
​是一个随 xx 的增加而单调递增的函数，  
第二项 `T2(x) = dp(k, n-x)`  
​是一个随着 x 的增加而单调递减的函数。  

这如何帮助我们来优化这个问题呢？当 x 增加时，`T1(x)` 单调递增而 `T1(x)` 单调递减，我们可以想象在一个直角坐标系中，横坐标为 x，纵坐标为 `T1(x)` 和 `T1(x)` 。当一个函数单调递增而另一个函数单调递减时，我们如何找到一个位置使得它们的最大值最小呢？  
**答案呼之欲出：找到交界点。
![力扣图片](https://assets.leetcode-cn.com/solution-static/887_fig1.jpg)  

在本题中，`T1(x)` 和 `T2(x)` 都是离散函数，也就是说，x 的值只能取 1,2,3 等等。在这种情况下，我们需要找到最大的满足 `T1(x) < T2(x)` 的 x0 ，以及最小的满足 `T1(x) > T2(x)` 的 x1 ，对应到上图中，就是离这两个函数（想象中的）交点左右两侧最近的整数。

我们只需要比较在 x0 和 x1 处两个函数的最大值，取一个最小的作为 x 即可。在数学上，我们可以证明出 x0 和 x1  
相差 1，这也是比较显然的，因为它们正好夹住了那个想象中的交点，并且相距尽可能地近。因此我们就可以使用二分查找的方法找出 x0 ，再得到 x1 ：  

- 我们在所有满足条件的 x 上进行二分查找。对于状态 (k,n) 而言，x 即为 `[1,n]` 中的任一整数；
- 在二分查找的过程中，假设当前这一步我们查找到了 x_mid, 如果 `T1(x_mid) > T2(x_mid)` 那么真正的 x_0 一定在 x_mid 的左侧，否则真正的 x_0 在 x_mid 的右侧。

二分查找的写法因人而异，本质上我们就是需要找到最大的满足 `T1(x) < T2(x)` 的 `x_0`，根据 `x_mid` 进行二分边界的调整。在得到了 `x_0` 后，我们可以知道 `x_1` 即为 `x_0 + 1`，此时我们只需要比较 `max{T1(x_0),T2(x_0)}` 和 `max{T1(x_1),T2(x_1)}`，取较小的那个对应的位置作为 x 即可。  

这样一来，对于给定的状态 (k, n)，我们只需要 O(logn) 的时间，通过二分查找就能得到最优的那个 x，因此时间复杂度从 O(kn^2) 降低至 O(knlogn)，可以通过本题。

~~~java
//力扣题解
class Solution {
    Map<Integer, Integer> memo = new HashMap<Integer, Integer>();

    public int superEggDrop(int k, int n) {
        return dp(k, n);
    }

    public int dp(int k, int n) {
        if (!memo.containsKey(n * 100 + k)) {
            int ans;
            if (n == 0) {
                ans = 0;
            } else if (k == 1) {
                ans = n;
            } else {
                int lo = 1, hi = n;
                while (lo + 1 < hi) {
                    int x = (lo + hi) / 2;
                    int t1 = dp(k - 1, x - 1);
                    int t2 = dp(k, n - x);

                    if (t1 < t2) {
                        lo = x;
                    } else if (t1 > t2) {
                        hi = x;
                    } else {
                        lo = hi = x;
                    }
                }

                ans = 1 + Math.min(Math.max(dp(k - 1, lo - 1), dp(k, n - lo)), Math.max(dp(k - 1, hi - 1), dp(k, n - hi)));
            }

            memo.put(n * 100 + k, ans);
        }

        return memo.get(n * 100 + k);
    }
}
~~~